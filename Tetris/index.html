<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
  <title>Play Retro Arcade – Tetris</title>
  <meta name="description" content="Play classic Tetris with modern graphics. Stack blocks, clear lines, and beat your high score!">
  <link rel="icon" href="../Public/logo.png" type="image/png">
  <style>
    :root {
      --bg: #0f0f12;
      --card: #18181c;
      --muted: #9aa0a6;
      --text: #e8eaed;
      --accent: #4fc3f7;
      --accent-hover: #29b6f6;
      --line: #2a2a30;
      --success: #4caf50;
      --warning: #ff9800;
      --error: #f44336;
      --gradient-primary: linear-gradient(135deg, #4fc3f7, #29b6f6, #03a9f4);
      --gradient-card: linear-gradient(145deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03));
      --shadow-elevated: 0 20px 40px rgba(0,0,0,0.4);
      --blur-glass: blur(10px);
      --purple: #a855f7;
      --blue: #3b82f6;
      --green: #10b981;
      --yellow: #f59e0b;
      --orange: #f97316;
      --red: #ef4444;
      --cyan: #06b6d4;
    }

    * { box-sizing: border-box; }
    html, body { 
      height: 100%; 
      margin: 0; 
      background: linear-gradient(135deg, #0b0b0d 0%, #1a1a1f 50%, #0f0f14 100%); 
      color: var(--text); 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      line-height: 1.6;
      overflow-x: hidden;
    }

    /* Animated background particles */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: 
        radial-gradient(circle at 20% 50%, rgba(79, 195, 247, 0.05) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(79, 195, 247, 0.03) 0%, transparent 50%),
        radial-gradient(circle at 40% 80%, rgba(79, 195, 247, 0.02) 0%, transparent 50%);
      animation: floatParticles 20s ease-in-out infinite;
      pointer-events: none;
      z-index: -1;
    }

    @keyframes floatParticles {
      0%, 100% { transform: translateY(0px) rotate(0deg); }
      33% { transform: translateY(-20px) rotate(2deg); }
      66% { transform: translateY(10px) rotate(-1deg); }
    }
    
    .wrap { max-width: 1000px; margin: 0 auto; padding: 20px; }
    
    header { 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      gap: 16px; 
      margin: 0 0 32px; 
      background: rgba(255, 255, 255, 0.03);
      backdrop-filter: var(--blur-glass);
      border: 1px solid rgba(79, 195, 247, 0.1);
      border-radius: 20px;
      padding: 24px 32px;
      box-shadow: var(--shadow-elevated);
      position: relative;
      overflow: hidden;
    }

    header::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(79, 195, 247, 0.05), transparent);
      animation: shimmer 3s ease-in-out infinite;
    }

    @keyframes shimmer {
      0% { left: -100%; }
      100% { left: 100%; }
    }

    h1 { 
      font-size: 24px; 
      margin: 0; 
      font-weight: 700;
      background: var(--gradient-primary);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      z-index: 1;
      position: relative;
    }
    
    .stats { display: flex; gap: 16px; align-items: center; flex-wrap: wrap; z-index: 1; position: relative; }
    
    .home-btn { 
      background: var(--gradient-primary); 
      color: #000; 
      border: none; 
      border-radius: 12px; 
      padding: 12px 20px; 
      font-size: 14px; 
      font-weight: 600; 
      cursor: pointer; 
      text-decoration: none; 
      display: inline-flex; 
      align-items: center; 
      gap: 8px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
      z-index: 1;
    }
    
    .home-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
      transition: left 0.5s ease;
    }
    
    .home-btn:hover { 
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(79, 195, 247, 0.4);
    }
    
    .home-btn:hover::before { left: 100%; }
    
    .logo { 
      width: 60px; 
      height: 60px; 
      object-fit: contain; 
      display: block; 
      image-rendering: crisp-edges;
      filter: drop-shadow(0 4px 12px rgba(79, 195, 247, 0.3));
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 1;
      position: relative;
    }
    .logo:hover { 
      transform: scale(1.1) rotate(5deg); 
      filter: drop-shadow(0 8px 20px rgba(79, 195, 247, 0.5));
    }
    
    .pill { 
      padding: 10px 16px; 
      border: 1px solid rgba(79, 195, 247, 0.2); 
      border-radius: 16px; 
      background: rgba(79, 195, 247, 0.1); 
      color: var(--text); 
      font-size: 14px; 
      font-weight: 500;
      backdrop-filter: var(--blur-glass);
      transition: all 0.3s ease;
    }
    .pill:hover {
      background: rgba(79, 195, 247, 0.15);
      border-color: var(--accent);
      transform: translateY(-1px);
    }
    
    .btn { 
      cursor: pointer; 
      border: 1px solid rgba(79, 195, 247, 0.2); 
      background: var(--gradient-card); 
      color: var(--text); 
      padding: 10px 16px; 
      border-radius: 12px; 
      font-size: 14px; 
      font-weight: 500;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      backdrop-filter: var(--blur-glass);
    }
    .btn:hover { 
      border-color: var(--accent); 
      background: rgba(79, 195, 247, 0.1);
      transform: translateY(-2px);
      box-shadow: 0 4px 16px rgba(79, 195, 247, 0.2);
    }
    
    .game-container { 
      display: grid; 
      grid-template-columns: 1fr auto 1fr; 
      gap: 28px; 
      align-items: start; 
      margin: 32px 0; 
    }
    
    .game-board { 
      position: relative; 
      background: var(--gradient-card); 
      border: 2px solid rgba(79, 195, 247, 0.2); 
      border-radius: 24px; 
      box-shadow: var(--shadow-elevated);
      backdrop-filter: var(--blur-glass);
      padding: 20px;
      transition: all 0.3s ease;
    }
    .game-board:hover {
      border-color: var(--accent);
      box-shadow: 
        var(--shadow-elevated),
        0 0 0 1px rgba(79, 195, 247, 0.3);
    }
    
    .game-canvas { 
      display: block; 
      border-radius: 16px; 
      box-shadow: inset 0 2px 10px rgba(0,0,0,0.3);
    }
    
    .side-panel { min-width: 160px; }
    
    .panel-section { 
      background: var(--gradient-card); 
      border: 1px solid rgba(79, 195, 247, 0.1); 
      border-radius: 16px; 
      padding: 20px; 
      margin-bottom: 20px;
      backdrop-filter: var(--blur-glass);
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }
    
    .panel-section::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, rgba(79, 195, 247, 0.05), transparent);
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }
    
    .panel-section:hover {
      border-color: rgba(79, 195, 247, 0.3);
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(0,0,0,0.2);
    }
    
    .panel-section:hover::before { opacity: 1; }
    
    .panel-title { 
      font-size: 16px; 
      font-weight: 600; 
      margin: 0 0 16px; 
      background: var(--gradient-primary);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      z-index: 1;
      position: relative;
    }
    
    .stat-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 12px 0;
      padding: 8px 12px;
      background: rgba(79, 195, 247, 0.05);
      border: 1px solid rgba(79, 195, 247, 0.1);
      border-radius: 8px;
      transition: all 0.3s ease;
    }
    
    .stat-item:hover {
      background: rgba(79, 195, 247, 0.1);
      border-color: rgba(79, 195, 247, 0.2);
    }
    
    .stat-label {
      color: var(--muted);
      font-size: 14px;
    }
    
    .stat-value {
      color: var(--accent);
      font-weight: 600;
      font-size: 16px;
    }
    
    .piece-stat {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 8px 0;
      padding: 6px 10px;
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(79, 195, 247, 0.05);
      border-radius: 6px;
      font-size: 12px;
    }
    
    .piece-stat:hover {
      background: rgba(79, 195, 247, 0.05);
    }
    
    .btn { 
      cursor: pointer; 
      border: 1px solid rgba(79, 195, 247, 0.2); 
      background: var(--gradient-card); 
      color: var(--text); 
      padding: 10px 16px; 
      border-radius: 12px; 
      font-size: 14px; 
      font-weight: 500;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      backdrop-filter: var(--blur-glass);
      display: block;
      width: 100%;
      margin-bottom: 8px;
      text-align: center;
    }
    .btn:hover { 
      border-color: var(--accent); 
      background: rgba(79, 195, 247, 0.1);
      transform: translateY(-2px);
      box-shadow: 0 4px 16px rgba(79, 195, 247, 0.2);
    }
    
    .next-canvas, .hold-canvas { 
      border: 2px solid rgba(79, 195, 247, 0.2); 
      border-radius: 12px; 
      background: rgba(0,0,0,0.3); 
      display: block; 
      margin: 0 auto;
      box-shadow: inset 0 2px 8px rgba(0,0,0,0.3);
    }
    
    .controls { 
      display: grid; 
      grid-template-columns: repeat(3, 1fr); 
      gap: 12px; 
      margin: 24px 0; 
    }
    
    .control-btn { 
      background: var(--gradient-card); 
      border: 1px solid rgba(79, 195, 247, 0.2); 
      color: var(--text); 
      border-radius: 16px; 
      padding: 16px 12px; 
      cursor: pointer; 
      font-size: 14px; 
      font-weight: 600; 
      text-align: center; 
      touch-action: manipulation; 
      user-select: none; 
      line-height: 1.2;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      backdrop-filter: var(--blur-glass);
      position: relative;
      overflow: hidden;
    }
    
    .control-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, rgba(79, 195, 247, 0.1), transparent);
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }
    
    .control-btn:hover {
      border-color: var(--accent);
      transform: translateY(-3px);
      box-shadow: 0 8px 20px rgba(79, 195, 247, 0.3);
    }
    
    .control-btn:hover::before { opacity: 1; }
    
    .control-btn:active { 
      transform: translateY(-1px); 
      box-shadow: 0 4px 12px rgba(79, 195, 247, 0.4);
    }
    
    .control-btn.wide { grid-column: span 2; }
    .control-icon { font-size: 24px; display: block; margin-bottom: 6px; z-index: 1; position: relative; }
    .control-text { font-size: 12px; font-weight: 500; opacity: 0.9; z-index: 1; position: relative; }
    
    .overlay { 
      position: absolute; 
      inset: 0; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      pointer-events: none; 
      background: rgba(0,0,0,0.8); 
      border-radius: 20px;
      backdrop-filter: var(--blur-glass);
    }
    .overlay.hidden { display: none; }
    
    .overlay .card { 
      pointer-events: auto; 
      background: var(--gradient-card); 
      border: 2px solid rgba(79, 195, 247, 0.3); 
      border-radius: 20px; 
      padding: 32px; 
      text-align: center; 
      backdrop-filter: var(--blur-glass);
      box-shadow: var(--shadow-elevated);
      position: relative;
      overflow: hidden;
    }
    
    .overlay .card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, rgba(79, 195, 247, 0.1), transparent);
      pointer-events: none;
    }
    
    .overlay h2 { 
      margin: 0 0 16px; 
      font-size: 28px; 
      background: var(--gradient-primary);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      z-index: 1;
      position: relative;
    }
    
    .overlay p { 
      margin: 12px 0 0; 
      color: var(--muted); 
      font-size: 16px;
      z-index: 1;
      position: relative;
    }
    
    footer { 
      opacity: 0.7; 
      margin: 24px 0 8px; 
      font-size: 14px; 
      text-align: center; 
      color: var(--muted);
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(79, 195, 247, 0.1);
      border-radius: 12px;
      padding: 16px;
      backdrop-filter: var(--blur-glass);
    }
    
    
    /* Responsive improvements */
    @media (max-width: 768px) {
      .wrap { padding: 16px; }
      .game-container { grid-template-columns: 1fr; gap: 20px; }
      .side-panel { 
        display: grid; 
        grid-template-columns: 1fr 1fr; 
        gap: 20px; 
      }
      header { 
        flex-direction: column; 
        gap: 16px; 
        align-items: stretch;
        padding: 20px;
      }
      header > div:first-child { 
        justify-content: center; 
        flex-wrap: wrap; 
        gap: 12px;
      }
      .stats { justify-content: center; }
      h1 { font-size: 20px; text-align: center; }
      .game-board { padding: 16px; }
    }
    
    @media (max-width: 480px) {
      .controls { grid-template-columns: repeat(2, 1fr); }
      .control-btn { padding: 12px 8px; font-size: 12px; }
      .control-icon { font-size: 20px; margin-bottom: 4px; }
      .control-text { font-size: 11px; }
      .stats { gap: 8px; }
      .pill { padding: 8px 12px; font-size: 12px; }
      .btn { padding: 8px 12px; font-size: 12px; }
      .logo { width: 48px; height: 48px; }
      .side-panel { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <a href="../index.html" class="home-btn">← Home</a>
      <img src="../Public/logo.png" alt="Logo" class="logo">
      <h1>Tetris — Play Retro Arcade</h1>
    </header>

    <div class="game-container">
      <div class="side-panel">
        <div class="panel-section">
          <h3 class="panel-title">Score</h3>
          <div class="stat-item">
            <span class="stat-label">Current</span>
            <span class="stat-value" id="score">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Level</span>
            <span class="stat-value" id="level">1</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Lines</span>
            <span class="stat-value" id="lines">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Best</span>
            <span class="stat-value" id="best">0</span>
          </div>
        </div>
        
        <div class="panel-section">
          <h3 class="panel-title">Hold</h3>
          <canvas id="holdCanvas" class="hold-canvas" width="80" height="80"></canvas>
        </div>
        
        <div class="panel-section">
          <h3 class="panel-title">Statistics</h3>
          <div class="piece-stat">
            <span>I:</span>
            <span id="stat-I">0</span>
          </div>
          <div class="piece-stat">
            <span>O:</span>
            <span id="stat-O">0</span>
          </div>
          <div class="piece-stat">
            <span>T:</span>
            <span id="stat-T">0</span>
          </div>
          <div class="piece-stat">
            <span>S:</span>
            <span id="stat-S">0</span>
          </div>
          <div class="piece-stat">
            <span>Z:</span>
            <span id="stat-Z">0</span>
          </div>
          <div class="piece-stat">
            <span>J:</span>
            <span id="stat-J">0</span>
          </div>
          <div class="piece-stat">
            <span>L:</span>
            <span id="stat-L">0</span>
          </div>
        </div>
      </div>

      <div class="game-board">
        <canvas id="gameCanvas" class="game-canvas" width="300" height="600"></canvas>
        <div id="overlay" class="overlay hidden">
          <div class="card">
            <h2 id="overlayTitle">Tetris</h2>
            <p id="overlayText">Press any key or tap to start</p>
          </div>
        </div>
      </div>

      <div class="side-panel">
        <div class="panel-section">
          <h3 class="panel-title">Next</h3>
          <canvas id="nextCanvas" class="next-canvas" width="80" height="80"></canvas>
        </div>
        
        <div class="panel-section">
          <h3 class="panel-title">Controls</h3>
          <button id="btnPause" class="btn" title="Pause/Resume (P)">⏯ Pause</button>
          <button id="btnRestart" class="btn" title="Restart (R)">🔄 Restart</button>
          <button id="btnMusic" class="btn" title="Toggle Music (M)">🎵 Music</button>
        </div>
        
        <div class="panel-section">
          <h3 class="panel-title">How to Play</h3>
          <div style="font-size: 12px; line-height: 1.4; color: var(--muted); z-index: 1; position: relative;">
            <div><strong>Move:</strong> ←→ / A/D</div>
            <div><strong>Rotate:</strong> ↑ / W</div>
            <div><strong>Soft Drop:</strong> ↓ / S</div>
            <div><strong>Hard Drop:</strong> Space</div>
            <div><strong>Hold:</strong> C / Shift</div>
            <div><strong>Pause:</strong> P key</div>
            <div><strong>Music:</strong> M key</div>
          </div>
        </div>
      </div>
    </div>

    <div class="controls">
      <button class="control-btn" data-action="rotate">
        <span class="control-icon">↑</span>
        <span class="control-text">Rotate</span>
      </button>
      <button class="control-btn" data-action="hold">
        <span class="control-icon">⌐</span>
        <span class="control-text">Hold</span>
      </button>
      <button class="control-btn" data-action="drop">
        <span class="control-icon">⎵</span>
        <span class="control-text">Hard Drop</span>
      </button>
      <button class="control-btn" data-action="left">
        <span class="control-icon">←</span>
        <span class="control-text">Left</span>
      </button>
      <button class="control-btn" data-action="down">
        <span class="control-icon">↓</span>
        <span class="control-text">Down</span>
      </button>
      <button class="control-btn" data-action="right">
        <span class="control-icon">→</span>
        <span class="control-text">Right</span>
      </button>
      <button class="control-btn wide" data-action="pause">
        <span class="control-icon">⏯</span>
        <span class="control-text">Pause</span>
      </button>
      <button class="control-btn" data-action="restart">
        <span class="control-icon">🔄</span>
        <span class="control-text">Restart</span>
      </button>
    </div>

    <footer>
      Controls: Move ←→ / A/D • Rotate ↑/W • Soft Drop ↓/S • Hard Drop Space • Hold C • Pause P • Music M
    </footer>
  </div>

  <!-- Audio Elements -->
  <audio id="backgroundMusic" loop preload="auto">
    <source src="../Sound/Action 1 (Loop).ogg?v=3" type="audio/ogg">
  </audio>
  
  <audio id="lineSound" preload="auto">
    <source src="../Sound/chiptune-jingle-1.ogg?v=3" type="audio/ogg">
  </audio>

  <script>
    // ====== TETRIS CONFIGURATION ======
    const BOARD_WIDTH = 10;
    const BOARD_HEIGHT = 20;
    const CELL_SIZE = 30;
    const CANVAS_WIDTH = BOARD_WIDTH * CELL_SIZE;
    const CANVAS_HEIGHT = BOARD_HEIGHT * CELL_SIZE;

    // Tetromino definitions (Standard Tetris pieces)
    const TETROMINOES = {
      I: {
        shape: [
          [0,0,0,0],
          [1,1,1,1],
          [0,0,0,0],
          [0,0,0,0]
        ],
        color: '#00f5ff'
      },
      O: {
        shape: [
          [1,1],
          [1,1]
        ],
        color: '#ffed00'
      },
      T: {
        shape: [
          [0,1,0],
          [1,1,1],
          [0,0,0]
        ],
        color: '#a000ff'
      },
      S: {
        shape: [
          [0,1,1],
          [1,1,0],
          [0,0,0]
        ],
        color: '#00ff00'
      },
      Z: {
        shape: [
          [1,1,0],
          [0,1,1],
          [0,0,0]
        ],
        color: '#ff0000'
      },
      J: {
        shape: [
          [1,0,0],
          [1,1,1],
          [0,0,0]
        ],
        color: '#0000ff'
      },
      L: {
        shape: [
          [0,0,1],
          [1,1,1],
          [0,0,0]
        ],
        color: '#ff7f00'
      }
    };

    // ====== GAME ELEMENTS ======
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const nextCanvas = document.getElementById('nextCanvas');
    const nextCtx = nextCanvas.getContext('2d');
    const holdCanvas = document.getElementById('holdCanvas');
    const holdCtx = holdCanvas.getContext('2d');
    
    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');
    const linesEl = document.getElementById('lines');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');
    
    const btnMusic = document.getElementById('btnMusic');
    const btnPause = document.getElementById('btnPause');
    const btnRestart = document.getElementById('btnRestart');
    
    const backgroundMusic = document.getElementById('backgroundMusic');
    const lineSound = document.getElementById('lineSound');

    // ====== GAME STATE ======
    let board = [];
    let currentPiece = null;
    let nextPiece = null;
    let heldPiece = null;
    let canHold = true;
    let score = 0;
    let level = 1;
    let lines = 0;
    let drops = 0;
    let gameState = 'welcome'; // 'welcome', 'playing', 'paused', 'gameOver'
    let dropTime = 0;
    let dropInterval = 1000; // ms
    let lastTime = 0;
    let musicEnabled = false;
    let musicInitialized = false;
    let statistics = { I: 0, O: 0, T: 0, S: 0, Z: 0, J: 0, L: 0 };
    let pieceBag = [];
    let nextBag = [];

    // ====== INITIALIZATION ======
    function initGame() {
      // Initialize board
      board = Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(0));
      
      // Set canvas size
      canvas.width = CANVAS_WIDTH;
      canvas.height = CANVAS_HEIGHT;
      
      // Load best score
      const savedBest = localStorage.getItem('tetrisBest');
      if (savedBest) {
        bestEl.textContent = savedBest;
      }
      
      // Initialize music
      initializeMusic();
      
      showOverlay('Tetris', 'Press any key or tap to start');
    }

    // ====== TETROMINO GENERATION ======
    function createPieceBag() {
      const types = Object.keys(TETROMINOES);
      const bag = [...types];
      
      // Fisher-Yates shuffle
      for (let i = bag.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [bag[i], bag[j]] = [bag[j], bag[i]];
      }
      
      return bag;
    }

    function getRandomTetromino() {
      // If current bag is empty, refill it
      if (pieceBag.length === 0) {
        pieceBag = createPieceBag();
        console.log('New piece bag created:', pieceBag.join(', '));
      }
      
      // Take next piece from bag
      const type = pieceBag.shift();
      
      return {
        type: type,
        shape: TETROMINOES[type].shape,
        color: TETROMINOES[type].color,
        x: Math.floor(BOARD_WIDTH / 2) - Math.floor(TETROMINOES[type].shape[0].length / 2),
        y: 0
      };
    }

    function spawnPiece() {
      if (!nextPiece) {
        nextPiece = getRandomTetromino();
      }
      
      currentPiece = nextPiece;
      nextPiece = getRandomTetromino();
      canHold = true;
      
      // Update statistics
      statistics[currentPiece.type]++;
      document.getElementById(`stat-${currentPiece.type}`).textContent = statistics[currentPiece.type];
      
      // Check game over
      if (collision(currentPiece, currentPiece.x, currentPiece.y)) {
        gameOver();
        return false;
      }
      
      drawNextPiece();
      return true;
    }

    // ====== COLLISION DETECTION ======
    function collision(piece, x, y) {
      for (let row = 0; row < piece.shape.length; row++) {
        for (let col = 0; col < piece.shape[row].length; col++) {
          if (piece.shape[row][col] && (
            x + col < 0 || 
            x + col >= BOARD_WIDTH || 
            y + row >= BOARD_HEIGHT ||
            (y + row >= 0 && board[y + row][x + col])
          )) {
            return true;
          }
        }
      }
      return false;
    }

    // ====== PIECE ROTATION ======
    function rotate(piece) {
      const rotated = piece.shape[0].map((_, index) => 
        piece.shape.map(row => row[index]).reverse()
      );
      return { ...piece, shape: rotated };
    }

    function rotatePiece() {
      if (!currentPiece) return;
      
      const rotated = rotate(currentPiece);
      
      // Try rotation at current position
      if (!collision(rotated, currentPiece.x, currentPiece.y)) {
        currentPiece = rotated;
        return;
      }
      
      // Try wall kicks (SRS - Super Rotation System simplified)
      const kicks = [[-1, 0], [1, 0], [0, -1], [-2, 0], [2, 0]];
      for (let [dx, dy] of kicks) {
        if (!collision(rotated, currentPiece.x + dx, currentPiece.y + dy)) {
          currentPiece = rotated;
          currentPiece.x += dx;
          currentPiece.y += dy;
          return;
        }
      }
    }

    // ====== PIECE MOVEMENT ======
    function movePiece(dx, dy) {
      if (!currentPiece) return false;
      
      if (!collision(currentPiece, currentPiece.x + dx, currentPiece.y + dy)) {
        currentPiece.x += dx;
        currentPiece.y += dy;
        return true;
      }
      return false;
    }

    function hardDrop() {
      if (!currentPiece) return;
      
      while (movePiece(0, 1)) {
        score += 2; // Bonus points for hard drop
      }
      placePiece();
    }

    // ====== PIECE PLACEMENT ======
    function placePiece() {
      if (!currentPiece) return;
      
      // Place piece on board
      for (let row = 0; row < currentPiece.shape.length; row++) {
        for (let col = 0; col < currentPiece.shape[row].length; col++) {
          if (currentPiece.shape[row][col]) {
            const boardY = currentPiece.y + row;
            const boardX = currentPiece.x + col;
            if (boardY >= 0) {
              board[boardY][boardX] = currentPiece.color;
            }
          }
        }
      }
      
      // Increment drop counter and check for speed increase
      drops++;
      if (drops % 10 === 0) {
        increaseSpeed();
      }
      
      // Check for line clears
      clearLines();
      
      // Spawn next piece
      spawnPiece();
    }

    // ====== LINE CLEARING ======
    function clearLines() {
      let linesCleared = 0;
      
      for (let row = BOARD_HEIGHT - 1; row >= 0; row--) {
        if (board[row].every(cell => cell !== 0)) {
          board.splice(row, 1);
          board.unshift(Array(BOARD_WIDTH).fill(0));
          linesCleared++;
          row++; // Check the same row again
        }
      }
      
      if (linesCleared > 0) {
        playLineSound();
        
        // Update lines and score
        lines += linesCleared;
        linesEl.textContent = lines;
        
        // Scoring system (NES Tetris)
        const lineScore = [0, 40, 100, 300, 1200][linesCleared] * level;
        score += lineScore;
        scoreEl.textContent = score;
        
        // Level progression (every 10 lines)
        const newLevel = Math.floor(lines / 10) + 1;
        if (newLevel > level) {
          level = newLevel;
          levelEl.textContent = level;
          updateDropInterval();
        }
        
        // Update best score
        updateBestScore();
      }
    }

    function updateDropInterval() {
      // Speed increase formula (similar to NES Tetris)
      dropInterval = Math.max(50, 1000 - (level - 1) * 50);
    }

    function increaseSpeed() {
      // Increase speed slightly every 10 drops (reduce interval by 5%)
      dropInterval = Math.max(50, dropInterval * 0.95);
      console.log(`Speed increased! Drop interval: ${dropInterval}ms (${drops} pieces dropped)`);
    }

    // ====== HOLD SYSTEM ======
    function holdPiece() {
      if (!currentPiece || !canHold) return;
      
      if (heldPiece) {
        // Swap current and held pieces
        const temp = heldPiece;
        heldPiece = {
          type: currentPiece.type,
          shape: TETROMINOES[currentPiece.type].shape,
          color: currentPiece.color
        };
        currentPiece = {
          ...temp,
          x: Math.floor(BOARD_WIDTH / 2) - Math.floor(temp.shape[0].length / 2),
          y: 0
        };
      } else {
        // Hold current piece and spawn new one
        heldPiece = {
          type: currentPiece.type,
          shape: TETROMINOES[currentPiece.type].shape,
          color: currentPiece.color
        };
        spawnPiece();
      }
      
      canHold = false;
      drawHeldPiece();
    }

    // ====== RENDERING ======
    function drawBoard() {
      // Clear canvas
      ctx.fillStyle = '#0a0a0a';
      ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      
      // Draw grid
      ctx.strokeStyle = '#1a1a1a';
      ctx.lineWidth = 1;
      for (let x = 0; x <= BOARD_WIDTH; x++) {
        ctx.beginPath();
        ctx.moveTo(x * CELL_SIZE, 0);
        ctx.lineTo(x * CELL_SIZE, CANVAS_HEIGHT);
        ctx.stroke();
      }
      for (let y = 0; y <= BOARD_HEIGHT; y++) {
        ctx.beginPath();
        ctx.moveTo(0, y * CELL_SIZE);
        ctx.lineTo(CANVAS_WIDTH, y * CELL_SIZE);
        ctx.stroke();
      }
      
      // Draw placed pieces
      for (let row = 0; row < BOARD_HEIGHT; row++) {
        for (let col = 0; col < BOARD_WIDTH; col++) {
          if (board[row][col]) {
            drawBlock(ctx, col * CELL_SIZE, row * CELL_SIZE, CELL_SIZE, board[row][col]);
          }
        }
      }
    }

    function drawBlock(context, x, y, size, color) {
      // Main block
      context.fillStyle = color;
      context.fillRect(x + 1, y + 1, size - 2, size - 2);
      
      // Highlight (top and left)
      context.fillStyle = lightenColor(color, 30);
      context.fillRect(x + 1, y + 1, size - 2, 3);
      context.fillRect(x + 1, y + 1, 3, size - 2);
      
      // Shadow (bottom and right)
      context.fillStyle = darkenColor(color, 30);
      context.fillRect(x + 1, y + size - 4, size - 2, 3);
      context.fillRect(x + size - 4, y + 1, 3, size - 2);
    }

    function lightenColor(color, percent) {
      const num = parseInt(color.replace("#", ""), 16);
      const amt = Math.round(2.55 * percent);
      const R = (num >> 16) + amt;
      const G = (num >> 8 & 0x00FF) + amt;
      const B = (num & 0x0000FF) + amt;
      return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 + 
        (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 + 
        (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
    }

    function darkenColor(color, percent) {
      const num = parseInt(color.replace("#", ""), 16);
      const amt = Math.round(2.55 * percent);
      const R = (num >> 16) - amt;
      const G = (num >> 8 & 0x00FF) - amt;
      const B = (num & 0x0000FF) - amt;
      return "#" + (0x1000000 + (R > 255 ? 255 : R < 0 ? 0 : R) * 0x10000 + 
        (G > 255 ? 255 : G < 0 ? 0 : G) * 0x100 + 
        (B > 255 ? 255 : B < 0 ? 0 : B)).toString(16).slice(1);
    }

    function drawCurrentPiece() {
      if (!currentPiece) return;
      
      for (let row = 0; row < currentPiece.shape.length; row++) {
        for (let col = 0; col < currentPiece.shape[row].length; col++) {
          if (currentPiece.shape[row][col]) {
            const x = (currentPiece.x + col) * CELL_SIZE;
            const y = (currentPiece.y + row) * CELL_SIZE;
            if (y >= 0) {
              drawBlock(ctx, x, y, CELL_SIZE, currentPiece.color);
            }
          }
        }
      }
    }

    function drawGhost() {
      if (!currentPiece) return;
      
      // Find ghost position
      let ghostY = currentPiece.y;
      while (!collision(currentPiece, currentPiece.x, ghostY + 1)) {
        ghostY++;
      }
      
      if (ghostY === currentPiece.y) return; // Ghost is at current position
      
      // Draw ghost piece
      ctx.globalAlpha = 0.3;
      for (let row = 0; row < currentPiece.shape.length; row++) {
        for (let col = 0; col < currentPiece.shape[row].length; col++) {
          if (currentPiece.shape[row][col]) {
            const x = (currentPiece.x + col) * CELL_SIZE;
            const y = (ghostY + row) * CELL_SIZE;
            if (y >= 0) {
              ctx.strokeStyle = currentPiece.color;
              ctx.lineWidth = 2;
              ctx.strokeRect(x + 2, y + 2, CELL_SIZE - 4, CELL_SIZE - 4);
            }
          }
        }
      }
      ctx.globalAlpha = 1;
    }

    function drawNextPiece() {
      if (!nextPiece) return;
      
      nextCtx.fillStyle = '#0a0a0a';
      nextCtx.fillRect(0, 0, 80, 80);
      
      const blockSize = 16;
      const offsetX = (80 - nextPiece.shape[0].length * blockSize) / 2;
      const offsetY = (80 - nextPiece.shape.length * blockSize) / 2;
      
      for (let row = 0; row < nextPiece.shape.length; row++) {
        for (let col = 0; col < nextPiece.shape[row].length; col++) {
          if (nextPiece.shape[row][col]) {
            drawBlock(nextCtx, 
              offsetX + col * blockSize, 
              offsetY + row * blockSize, 
              blockSize, 
              nextPiece.color
            );
          }
        }
      }
    }

    function drawHeldPiece() {
      holdCtx.fillStyle = '#0a0a0a';
      holdCtx.fillRect(0, 0, 80, 80);
      
      if (!heldPiece) return;
      
      const blockSize = 16;
      const offsetX = (80 - heldPiece.shape[0].length * blockSize) / 2;
      const offsetY = (80 - heldPiece.shape.length * blockSize) / 2;
      
      for (let row = 0; row < heldPiece.shape.length; row++) {
        for (let col = 0; col < heldPiece.shape[row].length; col++) {
          if (heldPiece.shape[row][col]) {
            drawBlock(holdCtx, 
              offsetX + col * blockSize, 
              offsetY + row * blockSize, 
              blockSize, 
              heldPiece.color
            );
          }
        }
      }
    }

    function render() {
      drawBoard();
      drawGhost();
      drawCurrentPiece();
    }

    // ====== GAME LOGIC ======
    function update(deltaTime) {
      if (gameState !== 'playing') return;
      
      dropTime += deltaTime;
      
      if (dropTime >= dropInterval) {
        if (!movePiece(0, 1)) {
          placePiece();
        }
        dropTime = 0;
      }
    }

    function gameLoop(currentTime) {
      const deltaTime = currentTime - lastTime;
      lastTime = currentTime;
      
      update(deltaTime);
      render();
      
      requestAnimationFrame(gameLoop);
    }

    // ====== GAME STATE MANAGEMENT ======
    function startGame() {
      gameState = 'playing';
      score = 0;
      level = 1;
      lines = 0;
      drops = 0;
      dropTime = 0;
      statistics = { I: 0, O: 0, T: 0, S: 0, Z: 0, J: 0, L: 0 };
      pieceBag = [];
      nextBag = [];
      
      // Reset UI
      scoreEl.textContent = '0';
      levelEl.textContent = '1';
      linesEl.textContent = '0';
      Object.keys(statistics).forEach(type => {
        document.getElementById(`stat-${type}`).textContent = '0';
      });
      
      // Reset board
      board = Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(0));
      
      // Reset pieces
      currentPiece = null;
      nextPiece = null;
      heldPiece = null;
      canHold = true;
      
      updateDropInterval();
      hideOverlay();
      spawnPiece();
      
      if (musicEnabled) {
        playBackgroundMusic();
      }
    }

    function pauseGame() {
      if (gameState === 'playing') {
        gameState = 'paused';
        pauseBackgroundMusic();
        showOverlay('Paused', 'Press P to continue');
      } else if (gameState === 'paused') {
        gameState = 'playing';
        hideOverlay();
        if (musicEnabled) {
          playBackgroundMusic();
        }
      }
    }

    function gameOver() {
      gameState = 'gameOver';
      stopBackgroundMusic();
      updateBestScore();
      showOverlay('Game Over', `Score: ${score} | Best: ${bestEl.textContent}<br>Press R to restart`);
    }

    function updateBestScore() {
      const currentBest = parseInt(bestEl.textContent);
      if (score > currentBest) {
        bestEl.textContent = score;
        localStorage.setItem('tetrisBest', score);
      }
    }

    // ====== UI FUNCTIONS ======
    function showOverlay(title, text) {
      overlayTitle.textContent = title;
      overlayText.innerHTML = text;
      overlay.classList.remove('hidden');
    }

    function hideOverlay() {
      overlay.classList.add('hidden');
    }

    // ====== AUDIO SYSTEM ======
    function initializeMusic() {
      if (musicInitialized) return;
      
      backgroundMusic.volume = 0.5;
      lineSound.volume = 0.8;
      
      // Load music preference
      const savedMusicEnabled = localStorage.getItem('tetrisMusicEnabled');
      if (savedMusicEnabled === 'true') {
        musicEnabled = true;
        btnMusic.textContent = '🔇 Music';
        btnMusic.title = 'Turn Off Music (M)';
      } else if (savedMusicEnabled === 'false') {
        musicEnabled = false;
        btnMusic.textContent = '🎵 Music';
        btnMusic.title = 'Turn On Music (M)';
      }
      
      musicInitialized = true;
    }

    function toggleMusic() {
      musicEnabled = !musicEnabled;
      
      if (musicEnabled) {
        btnMusic.textContent = '🔇 Music';
        btnMusic.title = 'Turn Off Music (M)';
        if (gameState === 'playing') {
          playBackgroundMusic();
        }
      } else {
        btnMusic.textContent = '🎵 Music';
        btnMusic.title = 'Turn On Music (M)';
        pauseBackgroundMusic();
      }
      
      localStorage.setItem('tetrisMusicEnabled', musicEnabled);
    }

    function playBackgroundMusic() {
      if (!musicEnabled) return;
      
      try {
        backgroundMusic.currentTime = 0;
        backgroundMusic.play().catch(e => console.log('Music autoplay prevented'));
      } catch (e) {
        console.log('Error playing music');
      }
    }

    function pauseBackgroundMusic() {
      try {
        backgroundMusic.pause();
      } catch (e) {
        console.log('Error pausing music');
      }
    }

    function stopBackgroundMusic() {
      try {
        backgroundMusic.pause();
        backgroundMusic.currentTime = 0;
      } catch (e) {
        console.log('Error stopping music');
      }
    }

    function playLineSound() {
      try {
        lineSound.currentTime = 0;
        lineSound.play().catch(e => console.log('Sound effect failed'));
      } catch (e) {
        console.log('Error playing line sound');
      }
    }

    // ====== INPUT HANDLING ======
    document.addEventListener('keydown', (e) => {
      if (gameState === 'welcome') {
        startGame();
        return;
      }
      
      if (gameState === 'gameOver' && (e.key === 'r' || e.key === 'R')) {
        startGame();
        return;
      }
      
      if (e.key === 'p' || e.key === 'P') {
        pauseGame();
        return;
      }
      
      if (e.key === 'm' || e.key === 'M') {
        toggleMusic();
        return;
      }
      
      if (gameState !== 'playing') return;
      
      switch (e.key.toLowerCase()) {
        case 'arrowleft':
        case 'a':
          movePiece(-1, 0);
          break;
        case 'arrowright':
        case 'd':
          movePiece(1, 0);
          break;
        case 'arrowdown':
        case 's':
          if (movePiece(0, 1)) {
            score += 1; // Soft drop bonus
            scoreEl.textContent = score;
          }
          break;
        case 'arrowup':
        case 'w':
          rotatePiece();
          break;
        case ' ':
          e.preventDefault();
          hardDrop();
          break;
        case 'c':
        case 'shift':
          holdPiece();
          break;
      }
    });

    // Touch controls
    document.querySelector('.controls').addEventListener('click', (e) => {
      const action = e.target.dataset.action;
      if (!action) return;
      
      if (gameState === 'welcome') {
        startGame();
        return;
      }
      
      switch (action) {
        case 'left':
          if (gameState === 'playing') movePiece(-1, 0);
          break;
        case 'right':
          if (gameState === 'playing') movePiece(1, 0);
          break;
        case 'down':
          if (gameState === 'playing' && movePiece(0, 1)) {
            score += 1;
            scoreEl.textContent = score;
          }
          break;
        case 'rotate':
          if (gameState === 'playing') rotatePiece();
          break;
        case 'drop':
          if (gameState === 'playing') hardDrop();
          break;
        case 'hold':
          if (gameState === 'playing') holdPiece();
          break;
        case 'pause':
          pauseGame();
          break;
        case 'restart':
          if (gameState === 'gameOver') startGame();
          break;
      }
    });

    // Button event listeners
    btnPause.onclick = pauseGame;
    btnRestart.onclick = () => {
      if (gameState === 'gameOver') startGame();
    };
    btnMusic.onclick = toggleMusic;

    // Canvas click to start
    canvas.addEventListener('click', () => {
      if (gameState === 'welcome') {
        startGame();
      }
    });

    // ====== INITIALIZATION ======
    initGame();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
